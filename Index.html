<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // K√≠ch th∆∞·ªõc √¥
    const gridSize = 25;
    const tileCount = canvas.width / gridSize;
    
    // Game state
    let snake = [{x: 10, y: 10}];
    let direction = {x: 0, y: 0};
    let nextDirection = {x: 0, y: 0};
    let food = {};
    let specialFood = null;
    let score = 0;
    let highScore = localStorage.getItem('snakeHighScore') || 0;
    let gameRunning = false;
    let gamePaused = false;
    let gameLoopInterval = null;
    
    // T·ªëc ƒë·ªô
    let baseSpeed = 200;
    let currentSpeed = 200;
    let speedMultiplier = 1;
    
    // ===== HACK ƒêI·ªÇM =====
    let hackActive = false;
    let hackValue = 10000; // S·ªë ƒëi·ªÉm nh·∫≠n ƒë∆∞·ª£c khi hack
    
    document.addEventListener('keydown', (e) => {
        if (e.key === 'h' || e.key === 'H') {
            hackActive = !hackActive;
            alert(`üîì HACK MODE: ${hackActive ? 'B·∫¨T' : 'T·∫ÆT'} - M·ªói l·∫ßn ƒÉn ƒë∆∞·ª£c +${hackValue} ƒëi·ªÉm!`);
        }
    });
    // ====================
    
    document.getElementById('highScore').textContent = highScore;
    document.getElementById('snakeLength').textContent = snake.length;
    
    // T·∫°o th·ª©c ƒÉn th∆∞·ªùng
    function generateFood() {
        let newFood;
        let validPosition = false;
        
        while (!validPosition) {
            newFood = {
                x: Math.floor(Math.random() * tileCount),
                y: Math.floor(Math.random() * tileCount)
            };
            
            validPosition = true;
            
            for (let segment of snake) {
                if (segment.x === newFood.x && segment.y === newFood.y) {
                    validPosition = false;
                    break;
                }
            }
            
            if (specialFood && newFood.x === specialFood.x && newFood.y === specialFood.y) {
                validPosition = false;
            }
        }
        
        food = newFood;
    }
    
    // T·∫°o th·ª©c ƒÉn ƒë·∫∑c bi·ªát
    function generateSpecialFood() {
        if (Math.random() < 0.15 && !specialFood) {
            let newSpecial;
            let validPosition = false;
            
            while (!validPosition) {
                newSpecial = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount),
                    type: Math.random() < 0.5 ? 'speed' : 'size'
                };
                
                validPosition = true;
                
                for (let segment of snake) {
                    if (segment.x === newSpecial.x && segment.y === newSpecial.y) {
                        validPosition = false;
                        break;
                    }
                }
                
                if (food.x === newSpecial.x && food.y === newSpecial.y) {
                    validPosition = false;
                }
            }
            
            specialFood = newSpecial;
            
            setTimeout(() => {
                specialFood = null;
                draw();
            }, 5000);
        }
    }
    
    // V·∫Ω game
    function draw() {
        ctx.fillStyle = '#0b1120';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // V·∫Ω l∆∞·ªõi
        ctx.strokeStyle = '#1e293b';
        ctx.lineWidth = 0.5;
        for (let i = 0; i <= tileCount; i++) {
            ctx.beginPath();
            ctx.moveTo(i * gridSize, 0);
            ctx.lineTo(i * gridSize, canvas.height);
            ctx.strokeStyle = '#1e293b';
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, i * gridSize);
            ctx.lineTo(canvas.width, i * gridSize);
            ctx.stroke();
        }
        
        // V·∫Ω th·ª©c ƒÉn th∆∞·ªùng
        ctx.shadowColor = '#ef4444';
        ctx.shadowBlur = 15;
        ctx.fillStyle = '#ef4444';
        ctx.beginPath();
        ctx.arc(food.x * gridSize + gridSize/2, food.y * gridSize + gridSize/2, gridSize/2 - 3, 0, Math.PI * 2);
        ctx.fill();
        
        // V·∫Ω th·ª©c ƒÉn ƒë·∫∑c bi·ªát
        if (specialFood) {
            if (specialFood.type === 'speed') {
                ctx.fillStyle = '#06b6d4';
                ctx.shadowColor = '#06b6d4';
            } else {
                ctx.fillStyle = '#eab308';
                ctx.shadowColor = '#eab308';
            }
            
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(specialFood.x * gridSize + gridSize/2, specialFood.y * gridSize + gridSize/2, gridSize/2 - 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'white';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(specialFood.type === 'speed' ? '‚ö°' : '‚≠ê', 
                       specialFood.x * gridSize + gridSize/2, 
                       specialFood.y * gridSize + gridSize/2);
        }
        
        // V·∫Ω r·∫Øn
        ctx.shadowBlur = 10;
        for (let i = 0; i < snake.length; i++) {
            const segment = snake[i];
            
            if (i === 0) {
                ctx.fillStyle = '#22c55e';
                ctx.shadowColor = '#22c55e';
            } else {
                const gradient = ctx.createLinearGradient(
                    segment.x * gridSize, 
                    segment.y * gridSize,
                    segment.x * gridSize + gridSize, 
                    segment.y * gridSize + gridSize
                );
                gradient.addColorStop(0, '#4ade80');
                gradient.addColorStop(1, '#16a34a');
                ctx.fillStyle = gradient;
                ctx.shadowColor = '#4ade80';
            }
            
            ctx.beginPath();
            ctx.roundRect(segment.x * gridSize + 2, segment.y * gridSize + 2, 
                        gridSize - 4, gridSize - 4, 8);
            ctx.fill();
            
            if (i === 0) {
                ctx.fillStyle = 'white';
                ctx.shadowBlur = 0;
                
                ctx.beginPath();
                ctx.arc(segment.x * gridSize + gridSize/2 - 5, 
                       segment.y * gridSize + gridSize/2 - 4, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(segment.x * gridSize + gridSize/2 + 5, 
                       segment.y * gridSize + gridSize/2 - 4, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#0f172a';
                ctx.beginPath();
                ctx.arc(segment.x * gridSize + gridSize/2 - 5, 
                       segment.y * gridSize + gridSize/2 - 4, 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(segment.x * gridSize + gridSize/2 + 5, 
                       segment.y * gridSize + gridSize/2 - 4, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // V·∫Ω th√¥ng b√°o hack n·∫øu ƒëang b·∫≠t
        if (hackActive) {
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#facc15';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('üîì HACK MODE', canvas.width - 20, 40);
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = '#ef4444';
            ctx.fillText(`+${hackValue} ƒëi·ªÉm/m·ªìi`, canvas.width - 20, 70);
        }
        
        ctx.shadowBlur = 0;
    }
    
    // Helper function cho roundRect
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.moveTo(x + r, y);
        this.lineTo(x + w - r, y);
        this.quadraticCurveTo(x + w, y, x + w, y + r);
        this.lineTo(x + w, y + h - r);
        this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        this.lineTo(x + r, y + h);
        this.quadraticCurveTo(x, y + h, x, y + h - r);
        this.lineTo(x, y + r);
        this.quadraticCurveTo(x, y, x + r, y);
        this.closePath();
        return this;
    };
    
    // C·∫≠p nh·∫≠t game
    function update() {
        if (!gameRunning || gamePaused) return;
        
        direction = {...nextDirection};
        
        const head = {
            x: snake[0].x + direction.x,
            y: snake[0].y + direction.y
        };
        
        if (head.x < 0) head.x = tileCount - 1;
        if (head.x >= tileCount) head.x = 0;
        if (head.y < 0) head.y = tileCount - 1;
        if (head.y >= tileCount) head.y = 0;
        
        for (let i = 0; i < snake.length; i++) {
            if (head.x === snake[i].x && head.y === snake[i].y) {
                gameOver();
                return;
            }
        }
        
        snake.unshift(head);
        
        // Ki·ªÉm tra ƒÉn th·ª©c ƒÉn th∆∞·ªùng - ƒê√É HACK
        if (head.x === food.x && head.y === food.y) {
            // ===== HACK ƒêI·ªÇM =====
            if (hackActive) {
                score += hackValue;  // +10000 ƒëi·ªÉm khi hack
            } else {
                score += 10;          // +10 ƒëi·ªÉm b√¨nh th∆∞·ªùng
            }
            // ====================
            
            document.getElementById('score').textContent = score;
            document.getElementById('snakeLength').textContent = snake.length;
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeHighScore', highScore);
                document.getElementById('highScore').textContent = highScore;
            }
            
            generateFood();
            generateSpecialFood();
        } else {
            // Ki·ªÉm tra ƒÉn th·ª©c ƒÉn ƒë·∫∑c bi·ªát - ƒê√É HACK
            if (specialFood && head.x === specialFood.x && head.y === specialFood.y) {
                // ===== HACK ƒêI·ªÇM =====
                if (hackActive) {
                    score += hackValue;  // +10000 ƒëi·ªÉm khi hack
                } else {
                    score += 20;          // +20 ƒëi·ªÉm b√¨nh th∆∞·ªùng
                }
                // ====================
                
                if (specialFood.type === 'speed') {
                    speedMultiplier = Math.min(speedMultiplier + 0.25, 2);
                    currentSpeed = Math.max(100, baseSpeed / speedMultiplier);
                    document.getElementById('speedLevel').textContent = speedMultiplier.toFixed(2);
                } else {
                    const lastSegment = snake[snake.length - 1];
                    snake.push({...lastSegment});
                    snake.push({...lastSegment});
                }
                
                document.getElementById('score').textContent = score;
                document.getElementById('snakeLength').textContent = snake.length;
                
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('snakeHighScore', highScore);
                    document.getElementById('highScore').textContent = highScore;
                }
                
                specialFood = null;
                generateSpecialFood();
            } else {
                snake.pop();
            }
        }
        
        document.getElementById('snakeLength').textContent = snake.length;
        draw();
    }
    
    function gameOver() {
        gameRunning = false;
        document.getElementById('finalScore').textContent = score;
        document.getElementById('gameOverlay').classList.add('active');
        
        document.getElementById('pauseBtn').disabled = true;
        document.getElementById('upBtn').disabled = true;
        document.getElementById('downBtn').disabled = true;
        document.getElementById('leftBtn').disabled = true;
        document.getElementById('rightBtn').disabled = true;
        
        if (gameLoopInterval) {
            clearInterval(gameLoopInterval);
            gameLoopInterval = null;
        }
    }
    
    function resetGame() {
        snake = [{x: 10, y: 10}];
        direction = {x: 0, y: 0};
        nextDirection = {x: 0, y: 0};
        score = 0;
        speedMultiplier = 1;
        currentSpeed = baseSpeed;
        specialFood = null;
        
        document.getElementById('score').textContent = '0';
        document.getElementById('speedLevel').textContent = '1.00';
        document.getElementById('snakeLength').textContent = '1';
        
        generateFood();
        draw();
        
        gameRunning = false;
        gamePaused = false;
        
        document.getElementById('startBtn').disabled = false;
        document.getElementById('pauseBtn').disabled = true;
        document.getElementById('pauseBtn').innerHTML = '<span>‚è∏</span> T·∫†M D·ª™NG';
        document.getElementById('upBtn').disabled = true;
        document.getElementById('downBtn').disabled = true;
        document.getElementById('leftBtn').disabled = true;
        document.getElementById('rightBtn').disabled = true;
        
        if (gameLoopInterval) {
            clearInterval(gameLoopInterval);
            gameLoopInterval = null;
        }
    }
    
    // Kh·ªüi t·∫°o
    generateFood();
    draw();
    
    // X·ª≠ l√Ω ph√≠m
    document.addEventListener('keydown', (e) => {
        if (!gameRunning || gamePaused) return;
        
        switch(e.key) {
            case 'ArrowUp':
                if (direction.y === 0) {
                    nextDirection = {x: 0, y: -1};
                }
                e.preventDefault();
                break;
            case 'ArrowDown':
                if (direction.y === 0) {
                    nextDirection = {x: 0, y: 1};
                }
                e.preventDefault();
                break;
            case 'ArrowLeft':
                if (direction.x === 0) {
                    nextDirection = {x: -1, y: 0};
                }
                e.preventDefault();
                break;
            case 'ArrowRight':
                if (direction.x === 0) {
                    nextDirection = {x: 1, y: 0};
                }
                e.preventDefault();
                break;
        }
    });
    
    // Event listeners
    document.getElementById('startBtn').addEventListener('click', () => {
        if (!gameRunning) {
            if (nextDirection.x === 0 && nextDirection.y === 0) {
                nextDirection = {x: 1, y: 0};
            }
            gameRunning = true;
            gamePaused = false;
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('upBtn').disabled = false;
            document.getElementById('downBtn').disabled = false;
            document.getElementById('leftBtn').disabled = false;
            document.getElementById('rightBtn').disabled = false;
            
            if (gameLoopInterval) {
                clearInterval(gameLoopInterval);
            }
            gameLoopInterval = setInterval(update, currentSpeed);
        }
    });
    
    document.getElementById('pauseBtn').addEventListener('click', () => {
        if (gameRunning) {
            gamePaused = !gamePaused;
            document.getElementById('pauseBtn').innerHTML = gamePaused ? 
                '<span>‚ñ∂</span> TI·∫æP T·ª§C' : '<span>‚è∏</span> T·∫†M D·ª™NG';
            
            if (!gamePaused) {
                if (gameLoopInterval) {
                    clearInterval(gameLoopInterval);
                }
                gameLoopInterval = setInterval(update, currentSpeed);
            }
        }
    });
    
    document.getElementById('resetBtn').addEventListener('click', resetGame);
    
    document.getElementById('restartBtn').addEventListener('click', () => {
        document.getElementById('gameOverlay').classList.remove('active');
        resetGame();
    });
    
    // Direction pad
    document.getElementById('upBtn').addEventListener('click', () => {
        if (gameRunning && !gamePaused && direction.y === 0) {
            nextDirection = {x: 0, y: -1};
        }
    });
    
    document.getElementById('downBtn').addEventListener('click', () => {
        if (gameRunning && !gamePaused && direction.y === 0) {
            nextDirection = {x: 0, y: 1};
        }
    });
    
    document.getElementById('leftBtn').addEventListener('click', () => {
        if (gameRunning && !gamePaused && direction.x === 0) {
            nextDirection = {x: -1, y: 0};
        }
    });
    
    document.getElementById('rightBtn').addEventListener('click', () => {
        if (gameRunning && !gamePaused && direction.x === 0) {
            nextDirection = {x: 1, y: 0};
        }
    });
                </script>
